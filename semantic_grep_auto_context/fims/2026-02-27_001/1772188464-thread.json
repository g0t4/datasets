{
  "last_sse":{
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "choices":[{
        "delta":[],
        "index":0,
        "finish_reason":"stop"
      }],
    "created":1772188466,
    "system_fingerprint":"b8115-77d6ae4ac",
    "timings":{
      "prompt_per_second":4347.9113039161,
      "prompt_ms":612.248,
      "prompt_per_token_ms":0.22999549211119,
      "predicted_ms":973.283,
      "cache_n":1938,
      "predicted_per_second":210.62733038592,
      "prompt_n":2662,
      "predicted_n":205,
      "predicted_per_token_ms":4.7477219512195
    },
    "object":"chat.completion.chunk",
    "id":"chatcmpl-hU6bY661JdTvdTaWYlA6WJr54dTr2EhE"
  },
  "response_message":{
    "_logged":true,
    "finish_reason":"stop",
    "content":"ace --all -- '[\\{\\}]' '' $command_b) (eval $command_b | psub)",
    "reasoning_content":"We need to complete the line after `-L $(string repl`. Probably similar to earlier line: `-L $(string replace --all -- '[\\{\\}]' '' $command_a) (eval $command_a | psub) \\` then next line `-L $(string replace ... $command_b) (eval $command_b | psub)`.\n\nSo fill: `ace --all -- '[\\{\\}]' '' $command_b) (eval $command_b | psub)`\n\nThus full line: `ace --all -- '[\\{\\}]' '' $command_b) (eval $command_b | psub)`\n\nBut need preceding part: `-L $(string replace`. So we output: `ace --all -- '[\\{\\}]' '' $command_b) (eval $command_b | psub)`.",
    "role":"assistant"
  },
  "request_body":{
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "_logged":true,
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: dotfiles\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Fish Shell Code Preferences\n\n- Use snake_case for functions and variables.\n- When a condition is ambiguous, assign it to a well‑named variable before the `if`.\n- Prefer long options, i.e. `--quiet` over `-q`, `--regex` over `-r`\n- Fish shell does not do word splitting like bash, no need to wrap everything in quotes!\n\n## Fish syntax examples\n\n```fish\n# exploit fish-isms!\n\n# use `not`, avoid `!`\nif not test -f spoon\n    echo There is no spoon\n    exit 1\nend\n\n# if + set\nif set -l message (some_command)\n    echo \"ok: $message\"\nelse\n    echo \"fail: $message\"\nend\n\n# prefer named arguments\nfunction show_variable -a name value\n    echo \"$name = $value\"\nend\n\n# fish doesn't have heredocs, use begin/end\nbegin\n    echo $header\n    echo $table\nend > out.html\n# or multi-line strings\necho \"\nfoo\nbar\n\" > test\n\n# every variable is an array\nset names wes john bob jane\nfor name in $names\n    echo $name\nend\n\nfor i in *.tmp\n    if grep DONE $i\n        break\n    end\n    if grep SKIP $i\n        continue\n    end\n    ...\nend\n\n# combine conditions\nwhile test -f foo.txt; or test -f bar.txt\n    ...\nend\n\n# conditional execution\nmake; and make install; or make clean\n```\n\n### builtin fish commands\n\nNow that we have more than 2KB of system RAM, we can fix most of what sucks about bash...\n\n```fish\n# *** string command\n\n# match: test, filter, extract\nstring match --quiet '*.lua' $file\nset lua_files (string match '*.lua' $files)\nset version (string match --regex 'v([0-9.]+)' $tag)\nstring match --index --regex 'ERROR' $line\n\n# replace: transform text\nset fixed (string replace foo bar $text)\nset cleaned (string replace --regex '\\s+' ' ' $line)\nset base (string replace --regex '\\.[^.]+$' '' $file)\nset normalized (string replace --filter --regex '^./' '' $paths)\n\n# split: tokenize\nset parts (string split ':' $PATH)\nset lines (string split '\\n' $text)\nset ext (string split --right --max 1 . $file)[2]\n\n# trim: clean edges\nset clean (string trim $line)\nset unquoted (string trim --chars '\"' $s)\n\n# join: build strings\nstring join ' ' $argv\nstring join --no-empty ':' $PATH\n\n# length and slicing\nstring length $name\nstring sub --start 2 --length 4 $word\nstring sub --start -5 $word\n\n# case conversion\nset key (string lower $key)\nset name (string upper $name)\n\n# shell-safe encoding\nset escaped (string escape $path)\nstring unescape $escaped\n\n# normalize piped output\nset text (some_command | string collect)\n\n\n# path command\npath basename foo/bar.txt # bar.txt\npath basename --no-extension foo/bar.txt # bar\npath dirname foo/bar.txt # foo\npath extension ./foo.mp4 # .mp4\npath change-extension mov ./foo.mp4 # ./foo.mov\n\npath normalize path/to//hello.txt # path/to/hello.txt\npath normalize path/to/../hello.txt # path/hello.txt\n# resolve = normalize + absolute path and follow symlinks\npath resolve foo  # ~/foo\n\npath sort 10-foo 2-bar\n# 2-bar\n# 10-foo\n\n\n# math command\nmath [(-s | --scale) N] [(-b | --base) BASE] [(-m | --scale-mode) MODE] EXPRESSION ...\nmath 10 / 6\nmath $status - 128\nmath \"5 * 2\"\nmath \"sin(pi)\"\nmath max 5,2,3,1\n\n\n# count STRING1 STRING2 ...\n# COMMAND | count\n# count [...] < FILE\ncount $PATH\ncount *.txt\ngit ls-files --others --exclude-standard | count\nprintf '%s\\n' foo bar | count baz # Returns 3 (2 lines from stdin plus 1 argument)\ncount < /etc/hosts # number of entries in hosts file\n\n\n# contains [OPTIONS] KEY [VALUES ...]\nif contains -- -q $argv\n    echo '$argv contains a -q option'\nend\n\n# scripts\nstatus filename # current running script\nstatus basename\nstatus dirname\nstatus function # current function name\nstatus line-number\nstatus stack-trace\n\n```\n\n\n## Recent yanks (copy to clipboard):\n```fish/load_last_interactive_only/diff-specific.fish\n    set command_a    (history --prefix \"cat test\" | head -1)\n```\n\n```fish/load_last_interactive_only/diff-specific.fish\n    set command_a    (history --prefix \"cat test\" | head -1)\n```\n\n```fish/load_last_interactive_only/diff-specific.fish\ndiff_two_commands\n```\n\n```fish/load_last_interactive_only/diff-specific.fish\nstring replace --all -- '\\\\\\$' '' $command_a)\n```\n\n```fish/load_last_interactive_only/diff-specific.fish\nstring replace --regex --all -- '[$\\']' '' $command_a\n```\n\n```fish/load_last_interactive_only/diff-specific.fish\n       -L \"'\"$(string replace --regex --all -- '[$\\'|\\{\\}]' '' $command_b)\"'\" (eval $command_b | psub)\n```\n\n```fish/load_last_interactive_only/diff-specific.fish\n       -L $(string replace --all -- '[\\{\\}]' '' $command_a) (eval $command_a | psub) \\\n```\n\n",
        "_logged":true,
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:675-694\n    string replace --regex '^treeu' \"treeu -L\" $argv\nend\n\n# *** *z functions to combine z cmd w/ opening editor to the repo root\nfunction cz\n    z $argv\n    code (_repo_root)\nend\nfunction zz\n    z $argv\n    zed (_repo_root)\nend\nfunction oz\n    z $argv\n    open (_repo_root)\nend\nfunction nz\n    z $argv\n    nvim\nend\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:659-661\nfunction treeX\n    string replace --regex '^tree' 'tree -L' $argv\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:674-676\nfunction treeuX\n    string replace --regex '^treeu' \"treeu -L\" $argv\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:669-671\nfunction treehX\n    string replace --regex '^treeh' \"treeh -L\" $argv\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:664-666\nfunction treedX\n    string replace --regex '^treed' \"treed -L\" $argv\nend\n",
        "_logged":true,
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```fish/load_last_interactive_only/diff-specific.fish\n\nfunction icdiff\n    # FYI I don't really like -H/--highlight as it often colors more than what is changed (icdiff help calls it \"ugly\")... so don't add -H here and force it globally... that can be tempting b/c the inversion pops better than font color... but then again the real issue I had was the default color map w/ yellow bold on yellow not standing out so I went with a color map mod instead:\n\n    # inject color map changes (bold yellow doesn't stand out well versus my typical yellow default font color)\n    # FYI default: --color-map='add:green_bold,change:yellow_bold,description:blue,meta:magenta,separator:blue,subtract:red_bold'\n    command icdiff --color-map='add:green_bold,change:white_bold,description:blue,meta:magenta,separator:blue,subtract:red_bold' $argv\n\n    # PRN wait until this causes a problem... but basically is there a case where I would want yellow_bold instead of white_bold? Probably not b/c if I have this modification for dotfiles then chances are I also have customized my terminal colors to make yellow font default and so white_bold will be a good choice then.\nend\n\n\nabbr ic \"icdiff\"\nabbr icr \"icdiff --recursive\" # diff all files in two dirs\nabbr icg git-icdiff\n# configure git-icdiff via git config: git config --global icdiff.options '--line-numbers'\n\nfunction _abbr_expand_diff_last_two_commands\n    set last_two_commands (history | head -n 2)\n    set -l command_a $last_two_commands[2]\n    set -l command_b $last_two_commands[1]\n    # test case:\n    #    echo 'foo'\n    #    echo 'foo\\nbar'\n    #    trigger diff_last_two_commands => needs escaped\n    set command_a (string escape $command_a)\n    set command_b (string escape $command_b)\n\n    echo diff_two_commands $command_a $command_b\nend\nabbr -a diff_last_two_commands --function _abbr_expand_diff_last_two_commands\n\n# * append sort -h too\n# FYI make sure original variant (above) is first completion result as I won't use this one as often\n#    also, consider breaking the typical completion chain so I can tab to complete the above w/o then another tab to select it\n# when output order might differ while content is the same\n# i.e. `ls` in two diff dirs\nfunction _abbr_expand_diff_last_two_commands_sorted\n    set last_two_commands (history | head -n 2)\n    set -l command_a $last_two_commands[2] \"| sort -h\"\n    set -l command_b $last_two_commands[1] \"| sort -h\"\n    set command_a (string replace --all -- \"'\" \"\\\\'\" $command_a)\n    set command_b (string replace --all -- \"'\" \"\\\\'\" $command_b)\n    echo diff_two_commands \"'$command_a'\" \"'$command_b'\"\nend\nabbr -a diff_last_two_commands_sorted --function _abbr_expand_diff_last_two_commands_sorted\n\nabbr -a diff_last_two_commands_stderr_too --function _abbr_expand_diff_last_two_commands_stderr_too\nfunction _abbr_expand_diff_last_two_commands_stderr_too\n    set last_two_commands (history | head -n 2)\n    set -l command_a $last_two_commands[2] \" 2>&1\"\n    set -l command_b $last_two_commands[1] \" 2>&1\"\n    set command_a (string replace --all -- \"'\" \"\\\\'\" $command_a)\n    set command_b (string replace --all -- \"'\" \"\\\\'\" $command_b)\n    echo diff_two_commands \"'$command_a'\" \"'$command_b'\"\nend\n\nfunction diff_two_commands --wraps icdiff\n    # usage:\n    #   diff_two_commands \"ls -al\" \"ls -al | sort -h\"\n    #   don't really need -- support here b/c there are only ever two args (commands to diff) and so any other options are clearly for icdiff (thus far)\n\n    # set command_a $argv[1]\n    # set command_b $argv[2]\n    set command_a (history --prefix \"cat test\" | head -1)\n    set command_b (history --prefix \"cat timing\" | head -1)\n    set icdiff_argv $argv[3..]\n    echo $command_a\n    string replace --regex --all -- '[$\\']' '' $command_a\n\n    icdiff $icdiff_argv \\\n       -L $(string replace --all -- '[\\{\\}]' '' $command_a) (eval $command_a | psub) \\\n       -L $(string repl<|fim_middle|>\n\nend\n\ndiff_two_commands\n\nfunction diff_command_args --wraps icdiff\n    # FYI to unambiguously pass icdiff options too, use --\n    #   diff_command_args [icdiff options] -- [diff args...]\n    #   diff_command_args -H -- \"ls -al\" -t\n\n    # argv[1] is the command to run\n    # $argv[2..-1] remainder of args are the diff args to pass (with and without)\n    #    if passing a pipe make sure to quote it else will not be an arg to this function!\n    #    e.g. diff_command_args \"echo foo\\nbar\" \"--line-numbers\" \"| grep foo\"\n    # ALSO, if there is no diff (and no error) then its very likely not this code but the output is literally the same :)... sometimes when testing you don't always get what you expect... run commands separately to verify if they are the same\n\n    # *** cannot do like diff_two_commands above b/c there are more 2+ args possible to the diff here and cannot differentiate which would be for icdiff vs comparison so just allowing the two special icdiff options\n    # FYI argparse strips specified options (i.e. -H/--highlight) AND strips -- (if present)...  so if you remove this then you will no longer be able to use --\n    argparse --ignore-unknown 'H/highlight' 'W/whole-file' -- $argv\n    # --ignore-unknown is necessary to avoid parsing args when \"--\" is not used\n\n    icdiff $_flag_highlight $_flag_whole_file \\\n        -L \"'$argv[1]'\" (eval $argv[1] | psub) \\\n        -L \"'$argv[1] $argv[2..-1]'\" (eval $argv[1] $argv[2..-1] | psub)\nend\n\nfunction _current_command_or_previous\n\n    set user_input (commandline -b)\n    if test -z $user_input\n        set user_input (history | head -n 1)\n        # PRN use $history (does it have items not added to history file, IIAC?)\n    end\n    echo $user_input\n\nend\n\n# *** bindings to replace current command with a diff_ helper command ***\n\nfunction _convert_current_command_to_diff_command_args\n    # use to compare same command w/ and w/o a set of args\n    set user_input (_current_command_or_previous)\n    commandline --replace \"diff_command_args '$user_input' \"\nend\n\nbind_both_modes_default_and_insert f5 _convert_current_command_to_diff_command_args\nbind_both_modes_default_and_insert ctrl-f5 _convert_current_command_to_diff_command_args # ctrl+F5 (streamdeck button => hotkey action)\n\nfunction _convert_current_command_to_diff_two_commands\n    # use to compare w/ add and remove from current command\n    set user_input (_current_command_or_previous)\n    commandline --replace \"diff_two_commands '$user_input' '$user_input' \"\nend\nbind_both_modes_default_and_insert f6 _convert_current_command_to_diff_two_commands\nbind_both_modes_default_and_insert ctrl-f6 _convert_current_command_to_diff_two_commands # ctrl+F6 (streamdeck button => hotkey action)\n# see which binding I prefer (F6 or streamdeck)\n#    yes I know I can reuse f6 for stremadeck too but I think I will get rid of that one and use it elsewhere so that is why I have both bound here for now\n\n# *** some bind key combos ***\n#\n#   read \"terminal input sequences\": https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences\n#\n#   examples (see wikipeida page for other lookups):\n#       F5          [15~\n#       F6          [17~\n#       F7          [18~\n#       shift + F7  [18;2~\n#       ctrl + F7   [18;5~   (see above where I use this, for proper escaping ])\n#       alt + F7    [18;9~\n#   modifiers (last #):\n#       shift    ;2~\n#       ctrl     ;5~\n#       alt      ;9~\n#\n#   exceptions (examples, there are many):\n#       shift+F1  [1;2P\n#       shift+F2  [1;2Q\n#       shift+F3  [1;2R\n#       shift+F4  [1;2S\n#         # very likely some of this has to do with how iterm maps bindings (it has choices for this and I should avoid changing that again without clearly knowing what I am doing :)...\n#\n\n\n#\n# FYI if want these then add back (maybe new file)... I never really have used these in zsh so I don't think they're pivotal here though I could do icdiff (!-2) (!-2) typed out and it would expand out to work in that one off case :)... still more work than other ways\n# # expand !!\n# # based on https://fishshell.com/docs/current/relnotes.html#fish-3-6-0-released-january-7-2023\n# function last_history_item\n```\n\n## Reminders about the cursor line:\nText before cursor: `       -L $(string repl`",
        "_logged":true,
        "role":"user"
      }],
    "model":"gpt-oss:120b",
    "top_p":1,
    "options":[],
    "max_tokens":4096,
    "stream":true,
    "raw":false,
    "temperature":1
  }
}