{
  "last_sse":{
    "choices":[{
        "delta":[],
        "index":0,
        "finish_reason":"stop"
      }],
    "timings":{
      "prompt_per_second":4435.019984873,
      "prompt_n":2926,
      "prompt_ms":659.749,
      "prompt_per_token_ms":0.22547812713602,
      "predicted_ms":1364.023,
      "predicted_per_token_ms":4.3302317460317,
      "predicted_per_second":230.93452236509,
      "predicted_n":315,
      "cache_n":1833
    },
    "object":"chat.completion.chunk",
    "id":"chatcmpl-WBpPGhv7se0Zcl6Njk6TiR1sJJXxlM7a",
    "created":1772016819,
    "system_fingerprint":"b8115-77d6ae4ac",
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "role":"assistant",
    "_logged":true,
    "content":"set indent (string repeat -n $level \" \")\nstring replace --regex '^' $indent $argv",
    "finish_reason":"stop",
    "reasoning_content":"We need to complete the function string_indent. Likely want to indent string by spaces. Use string repeat? In fish, to repeat spaces: string repeat -n $level \" \" $string? Actually string repeat repeats string N times. So implement: string repeat -n $level \" \" $argv? The function likely takes a string via stdin? Probably want to prefix each line with indentation. Could be: string replace -r '^' (string repeat -n $level \" \") $argv. Simpler: string repeat -n $level \" \" ; then echo \"$indent$argv\". But function signature: --argument-names level, so $argv contains remaining args (string). So implement:\n\nif test (count $argv) -eq 0\n    return\nend\nset indent (string repeat -n $level \" \")\nstring replace --regex '^' $indent $argv\n\nThus return indented string. Provide code line.\n\nWe need to replace <|fim_middle|> with the body after string. So replace with:\n\nif test -z \"$level\"\n    set level 1\nend\nset indent (string repeat -n $level \" \")\nstring replace --regex '^' $indent $argv\n\nBut we already have level handling earlier. So just:\n\nset indent (string repeat -n $level \" \")\nstring replace --regex '^' $indent $argv\n\nThus final."
  },
  "request_body":{
    "top_p":1,
    "max_tokens":4096,
    "stream":true,
    "messages":[{
        "role":"developer",
        "_logged":true,
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "_logged":true,
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: dotfiles\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Fish Shell Code Preferences\n\n- Use snake_case for functions and variables.\n- When a condition is ambiguous, assign it to a well‑named variable before the `if`.\n- Prefer long options, i.e. `--quiet` over `-q`, `--regex` over `-r`\n- Fish shell does not do word splitting like bash, no need to wrap everything in quotes!\n\n## Fish syntax examples\n\n```fish\n# exploit fish-isms!\n\n# use `not`, avoid `!`\nif not test -f spoon\n    echo There is no spoon\n    exit 1\nend\n\n# if + set\nif set -l message (some_command)\n    echo \"ok: $message\"\nelse\n    echo \"fail: $message\"\nend\n\n# prefer named arguments\nfunction show_variable -a name value\n    echo \"$name = $value\"\nend\n\n# fish doesn't have heredocs, use begin/end\nbegin\n    echo $header\n    echo $table\nend > out.html\n# or multi-line strings\necho \"\nfoo\nbar\n\" > test\n\n# every variable is an array\nset names wes john bob jane\nfor name in $names\n    echo $name\nend\n\nfor i in *.tmp\n    if grep DONE $i\n        break\n    end\n    if grep SKIP $i\n        continue\n    end\n    ...\nend\n\n# combine conditions\nwhile test -f foo.txt; or test -f bar.txt\n    ...\nend\n\n# conditional execution\nmake; and make install; or make clean\n```\n\n### builtin fish commands\n\nNow that we have more than 2KB of system RAM, we can fix most of what sucks about bash...\n\n```fish\n# *** string command\n\n# match: test, filter, extract\nstring match --quiet '*.lua' $file\nset lua_files (string match '*.lua' $files)\nset version (string match --regex 'v([0-9.]+)' $tag)\nstring match --index --regex 'ERROR' $line\n\n# replace: transform text\nset fixed (string replace foo bar $text)\nset cleaned (string replace --regex '\\s+' ' ' $line)\nset base (string replace --regex '\\.[^.]+$' '' $file)\nset normalized (string replace --filter --regex '^./' '' $paths)\n\n# split: tokenize\nset parts (string split ':' $PATH)\nset lines (string split '\\n' $text)\nset ext (string split --right --max 1 . $file)[2]\n\n# trim: clean edges\nset clean (string trim $line)\nset unquoted (string trim --chars '\"' $s)\n\n# join: build strings\nstring join ' ' $argv\nstring join --no-empty ':' $PATH\n\n# length and slicing\nstring length $name\nstring sub --start 2 --length 4 $word\nstring sub --start -5 $word\n\n# case conversion\nset key (string lower $key)\nset name (string upper $name)\n\n# shell-safe encoding\nset escaped (string escape $path)\nstring unescape $escaped\n\n# normalize piped output\nset text (some_command | string collect)\n\n\n# path command\npath basename foo/bar.txt # bar.txt\npath basename --no-extension foo/bar.txt # bar\npath dirname foo/bar.txt # foo\npath extension ./foo.mp4 # .mp4\npath change-extension mov ./foo.mp4 # ./foo.mov\n\npath normalize path/to//hello.txt # path/to/hello.txt\npath normalize path/to/../hello.txt # path/hello.txt\n# resolve = normalize + absolute path and follow symlinks\npath resolve foo  # ~/foo\n\npath sort 10-foo 2-bar\n# 2-bar\n# 10-foo\n\n\n# math command\nmath [(-s | --scale) N] [(-b | --base) BASE] [(-m | --scale-mode) MODE] EXPRESSION ...\nmath 10 / 6\nmath $status - 128\nmath \"5 * 2\"\nmath \"sin(pi)\"\nmath max 5,2,3,1\n\n\n# count STRING1 STRING2 ...\n# COMMAND | count\n# count [...] < FILE\ncount $PATH\ncount *.txt\ngit ls-files --others --exclude-standard | count\nprintf '%s\\n' foo bar | count baz # Returns 3 (2 lines from stdin plus 1 argument)\ncount < /etc/hosts # number of entries in hosts file\n\n\n# contains [OPTIONS] KEY [VALUES ...]\nif contains -- -q $argv\n    echo '$argv contains a -q option'\nend\n\n# scripts\nstatus filename # current running script\nstatus basename\nstatus dirname\nstatus function # current function name\nstatus line-number\nstatus stack-trace\n\n```\n"
      },{
        "role":"user",
        "_logged":true,
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/ask-openai.fish:107-144\nfunction ask_openai\n\n    set -l user_input (commandline -b)\n\n    # FYI not appending '# thinking...' b/c it doesn't show AND doing so is messing up the prompt if a space typed before this func is invoked\n\n    set -l _python3 \"$WES_DOTFILES/.venv/bin/python3\"\n    set -l _single_py \"$WES_DOTFILES/zsh/universals/3-last/ask-openai/single.py\"\n    set -l _single_rs \"$WES_DOTFILES/zsh/universals/3-last/ask-openai/rusts/target/debug/rusts\"\n\n    if string match --regex -q \"git commit -m\" $user_input\n        # *** future => ask openai first for any supplementary info it may want (based on user_input) and then I can query that and pass it with normal question and it can decide when I am committing and want a suggested commit description and ask for git_diff and I provide it... so I could have a list of context functions (git_diff, list_files, pwd, ip_addys, etc) it can ask to be invoked and passed with user_input ... also could just pass all the contextual info upfront and not have back and forth which is premature optimization most likely! until I get a ton of background data that might confuse things I could just provide all of it every time?\n        # ? give it recent commit messages too?\n        # if using git commit => pass git diff and ask it to write a commit message\n        set git_diff (git diff --cached --no-color)\n        set response ( \\\n            echo -e \"env: fish on $(uname)\\nquestion: write me a commit message, here is the git diff:\\n$git_diff\" | \\\n            $_python3 $_single_py $ask_service 2>&1 \\\n        )\n    else\n        set response ( \\\n            echo -e \"env: fish on $(uname)\\nquestion: $user_input\" | \\\n            $_single_rs 2>&1 \\\n        )\n    end\n    set exit_code $status\n    if test $exit_code -eq 2\n        commandline --replace \"[CONTEXT]: $response\"\n        # FYI other causes rc=2 print as context (i.e. wrong path to python script, NBD as error shows anyways)\n    else if test $exit_code -ne 0\n        commandline --replace \"[FAIL]: $response\"\n    else\n        commandline --replace $response\n    end\n    # FYI ctrl+z can undo replacment\n\n    # `fish_commandline_append` doesn't use repaint, so I assume I don't need to\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/functions/is_empty.fish:2-10\nfunction is_empty \\\n    --argument what \\\n    --description \"use instead of test -z/n!\"\n    if string length --quiet -- $what\n        return 1 # Not empty, return false in terms of emptiness\n    else\n        return 0 # Empty, return true in terms of emptiness\n    end\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:451-453\nfunction duX\n    string replace --regex '^du' 'grc du -hd' $argv\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/diff-specific.fish:114-118\nfunction _convert_current_command_to_diff_two_commands\n    # use to compare w/ add and remove from current command\n    set user_input (_current_command_or_previous)\n    commandline --replace \"diff_two_commands '$user_input' '$user_input' \"\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-specific.fish:569-577\nfunction forr_abbr\n    set count (string replace \"forr\" \"\" $argv)\n    if test -z \"$count\"; or test $count -eq 30\n        echo 'echo LINES: $LINES'\n        echo 'echo COLUMNS: $COLUMNS'\n        return\n    end\n    echo \"seq 1 $count | xargs -I {} echo {}\"\nend\n"
      },{
        "role":"user",
        "_logged":true,
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```fish/load_last_interactive_only/misc-specific.fish\nabbr --set-cursor stracec \"strace -c -e trace=all sleep 1\"\nabbr --set-cursor straceC \"strace -C -e trace=all sleep 1\"\n\n# *** fish\nabbr --set-cursor -- fishc \"fish -c '%'\"\nabbr pPATH 'for p in $PATH; echo $p; end'\n\n# *** openai completions helpers\n\n# not just psse b/c I can't get tab completion of --position=anywhere abbreviations\n#  strip until first { .. that way any prefix (data: and/or log messages) are stripped at front of line\n#    that means I can double click a line in llama-server logs and copy all of it and jq just works!\nset --local sse_jq 'string replace --regex \"[^{]*\" \"\" | jq'\n# pipe alone (not from clippy)\nabbr --position=anywhere -- psse \"| $sse_jq\"\nabbr --position=anywhere -- pssec \"| $sse_jq --compact-output\"\n# pbpaste then pipe\nabbr -- pbsse \"pbpaste | $sse_jq\"\nabbr -- pbssec \"pbpaste | $sse_jq --compact-output\"\n# grab __verbose.prompt (llama-server uses this)\nabbr -- pbsse_verbose_prompt \"pbpaste | $sse_jq '.__verbose.prompt' -r\"\n# TODO I really need to write my own script (python?) and have this do detection on the prompt value and just auto suggest adding treesitter on the end\n#    and add support for other formats and coloring them\nabbr -- pbsse_verbose_prompt_harmony \"pbpaste | $sse_jq '.__verbose.prompt' -r | tree-sitter highlight --scope source.harmony\"\nabbr -- pbsse_verbose_content \"pbpaste | $sse_jq '.__verbose.content' -r\" # this is the RAW RESPONSE from the model\nabbr -- pbsse_verbose_raw_response \"pbpaste | $sse_jq '.__verbose.content' -r\" # this is the RAW RESPONSE from the model\nabbr -- pbsse1 \"pbpaste | $sse_jq > input-messages.json\"\nabbr -- pbsse2 \"pbpaste | $sse_jq > input-rendered-prompt.json\"\nabbr -- pbsse3 \"pbpaste | $sse_jq > output-parsed-message.json\"\nabbr -- pbssethread 'ask_thread_reviewer (pbpaste | string replace --regex \"[^{]*\" \"\" | psub)'\n\n#\n# * pbsse4 (raw prompt)\n# FYI sse4 is not an sse but the naming convention helps me quickly remember each of these! (first 3 are SSEs)\nabbr -- pbsse4 \"pbpaste | string replace --regex '^\\w\\w\\w \\d\\d \\d\\d:\\d\\d:\\d\\d \\w+ llama-server\\[\\d+\\]: ' '' | string replace 'Parsing input with format GPT-OSS: ' '' > output-raw.harmony\"\n# strip this from all lines:\n#   Dec 09 18:11:03 build21 llama-server[3344]:\n# then first line also has:\n#   Parsing input with format GPT-OSS:\n#\n# FYI I assume line breaks in logs are from literal line breaks in the response that s/b preserved\n#  TODO setup to work with other prompt types... not just GPT-OSS/harmony... i.e. Qwen3\n#  TODO and setup to rename file based on prompt format (if applicable?) .. at least not call it .harmony :)\n\n# ? --join-output\n\n# * date\nabbr date_s \"date +%s\"\nreminder_abbr date_unixtime \"date +%s\" # reminder abbr\n\n## general cd\nabbr cdr 'cd \"$(_repo_root)\"' # * favorite\n\n## open\nabbr orr 'open \"$(_repo_root)\"' # can't use `or` in fish :)\nabbr oh 'open .'\n\n####### vscode aliases:\nabbr ch 'code .' # * favorite\nabbr cih 'code-insiders .'\nabbr cr 'code \"$(_repo_root)\"' # * favorite\nabbr cir 'code-insiders \"$(_repo_root)\"'\n## adv\nabbr cie 'code --inspect-extensions=9229 .' # attach then with devtools, mostly adding this so I remember it\nabbr cieb 'code --inspect-brk-extensions=9229 .' # attach, set breakpoints, then run!\n\n#### zed\nabbr zh 'zed .'\nabbr zr 'zed \"$(_repo_root)\"'\nabbr zph 'zed-preview .'\nabbr zpr 'zed-preview \"$(_repo_root)\"'\n\n### cursor\nabbr cs 'cursor .'\nabbr csr 'cursor \"$(_repo_root)\"'\n\n# z\nabbr zx 'z -x'\n\n# tar:\nabbr tarx 'tar -xf' # e(x)tract\nabbr tarx_stdout 'tar -O -xf' # e(x)tract to std(O)ut\nabbr tart 'tar -tf' # lis(t) / (t)est\nabbr tarc 'tar --xz -cf' # create xz (todo use set-position to put cursor in name that already has .txz extension)\nabbr tarcg 'tar --gzip -cf' # create gzip (todo use set-position to put cursor in name that already has .tgz extension)\nabbr tarcb 'tar --bzip2 -cf' # create bzip2 (todo use set-position to put cursor in name that already has .tbz2 extension)\n\n# *** jar (zip)\nabbr jarx 'jar -xf' # e(x)tract\nabbr jart 'jar -tf' # lis(t) / (t)est\nabbr --set-cursor -- jartree 'jar -tf %.jar | treeify'\nabbr jaru 'jar -uf' # u(n)pack\nabbr jarc 'jar -cf' # create\n# TODO more based on jar/zip/unzip (FYI bsdtar supports zip, not gnu tar)\n\n# *** unzip\nabbr unzipx_stdout 'unzip -p' # e(x)tract to std(O)ut\nabbr unzipl 'unzip -l' # lis(t) / (t)est\n# TODO flesh out later, FYI use zip for create equivalaents\n#   PRN make all these abbrs via zip and unzip? same set and just use respective command based on action? (unlike tar which has one command for all ops)\n\n# *** java abbrs\nabbr java19 'export PATH=\"$(/usr/libexec/java_home -v 19)/bin:$PATH\"'\n\n# *** jcmd\nabbr jcmd_screenpal \"jcmd \\$(screenpal_pid) \" # get PID with `jcmd` or `jps` or `ps aux | grep ScreenPal`\n\n# *** mvn\nabbr mvnls 'mvn dependenices:list'\nabbr mvntree 'mvn dependenices:tree'\nabbr mvnc 'mvn compile'\nabbr mvnp 'mvn package'\nabbr mvnt 'mvn test'\n\n# *** screenpal\nabbr spkill \"pkill -ilf screenpal\"\n# abbr spkilltray \"pkill -ilf 'screenpal tray'\"\nabbr spkilltray \"echo disable tray app in partner properties file\"\nabbr splog \"cat ~/Library/ScreenPal-v3/app-0.log\"\nabbr splogrm \"rm ~/Library/ScreenPal-v3/app-0.log\"\n# PRN tray-0.log ... but don't need it right now\nfunction screenpal_pid\n    set --local pid (jcmd | grep ScreenPal | head -1 | cut -d' ' -f1)\n    echo $pid\nend\n\n# *** streamdeck icon helpers\n\nfunction streamdeck_svg2png_padded_square_only\n    # FTR this was desigend initially to work with screenpal icons (svgs) extracted from JARs which are square to start\n\n    if not test -d drop-originals-svgs-here\n        echo \"CRAP: missing dir 'drop-originals-svgs-here', created it for you, now put your SVGs in it\"\n        mkdir -p drop-originals-svgs-here\n        return 1\n    end\n\n    mkdir -p final tmp_pngs\n\n    for image in drop-originals-svgs-here/*.svg\n        # * make 96px wide PNG (height is scaled)\n        set base (basename $image .svg)\n        set new_png \"tmp_pngs/$base.png\"\n        svg2png --width=96 $image $new_png\n\n        # * make 120px PNG with padding around the 96px PNG\n        set new_padded \"final/$base.padded.png\"\n        set width 120\n        magick \"$new_png\" -gravity center -background transparent -extent 120x120 \"$new_padded\"\n    end\nend\n\n# *** string extensions\n\nfunction string_indent --argument-names level\n    if test -z \"$level\"\n        set level 1\n    end\n    string <|fim_middle|>\nend\n```\n\n## Reminders about the cursor line:\nText before cursor: `    string `"
      }],
    "temperature":1,
    "model":"gpt-oss:120b",
    "options":[],
    "raw":false,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    }
  }
}