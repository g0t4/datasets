{
  "request_body":{
    "options":[],
    "top_p":1,
    "temperature":1,
    "max_tokens":4096,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "_logged":true
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: ask-openai.nvim\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Lua Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Prefer EmmyLua/LuaLS style annotations\n- Always annotate when type inference would be ambiguous, or for public APIs.\n\nExamples:\n```lua\n---@param names string[]\n---@param checker fun(name: string): boolean\n---@return table<string, integer>\nfunction process_names(names, checker) end\n\n---@class WindowController\n---@field window hs.axuielement\n---@field title? string\n---@field size { w: number, h: number }\nlocal WindowController = {}\n```\n\n\n\n## Recent yanks (copy to clipboard):\n```lua/ask-openai/rag/init.lua\n            if client.name ~= \"ask_language_server\" then\n                return\n            end\n```\n\n```lua/ask-openai/rag/init.lua\n            log:info(string.format(\"LSP attached: %s (buf %d)\", client.name, ev.buf))\n```\n\n```lua/ask-openai/rag/init.lua\n            if not client then\n                return\n            end\n```\n\n```lua/ask-openai/rag/init.lua\n            if not client then return end\n```\n\n```lua/ask-openai/rag/init.lua\n            if not client or client.name ~= \"ask_language_server\" then return end\n```\n\n```lua/ask-openai/rag/init.lua\n            if not client then\n                log:info(string.format(\"LspDetach - client not found (buf %d)\", args.buf))\n```\n\n```lua/ask-openai/rag/init.lua\n        --- @param args {id:number }\n```\n\n```lua/ask-openai/rag/init.lua\n                log:info(string.format(\"LSP attached: %s (buf %d)\", event_args.data.client_id, event_args.buf))\n```\n\n",
        "_logged":true
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/context/yanks.lua:28-33\n                 function()\n        messages.ensure_open()\n        messages.header(\"Yanking\")\n        messages.append(current_file_relative_to_workspace_root)\n        messages.append(vim.inspect(event))\n    end\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rx/scheduler.lua:35-37\n                                            function()\n        action(unpack(packed_args)) -- lua 5.1 is unpack (not table.unpack yet) => nvim is 5.1\n    end\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/context/edits.lua:0-6\nlocal RingBuffer = require(\"ask-openai.predictions.edits.ring_buffer\")\nlocal messages = require(\"devtools.messages\")\n\nlocal edit_log = RingBuffer.new(500)\n\nvim.api.nvim_create_autocmd({ \"TextChanged\", \"TextChangedI\" }, {\n    callback = \n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/helpers/float_window.lua:79-84\n,\n    })\n    vim.api.nvim_create_autocmd(\"WinClosed\", {\n        group = group_id,\n        pattern = tostring(self.win_id),\n        callback = \n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/helpers/selection.tests.lua:38-45\n                                                                                                               function()\n            vim.cmd(':0')\n            vim.cmd('normal! 0vv') -- second v exits\n            -- by the way, just enabling visual mode selects the current character (under cursor)\n            local selection = get_selection()\n            should.be_equal(selection.original_text, 'f')\n            should.be_equal(\"[r1,c1]-[r1,c1] 1-indexed\", selection:range_str())\n        end\n",
        "_logged":true
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```lua/ask-openai/rag/init.lua\n            -- \".git\", -- common, but in my case I need .rag (in fact, LS should never be setup if there's no .rag dir, so this would never be called)\n        })\n\n        -- TODO comment out logs once you are comfortable w/ migration to vim.lsp.config\n        if root then\n            -- ONLY start LS if you find a root\n            log:info(string.format(\"found ask-LS root=%s, bufnr=%d %s\", tostring(root), bufnr, filepath))\n            on_dir(root)\n            return\n        end\n        log:warn(string.format(\"no ask-LS root found for bufnr=%d %s\", bufnr, filepath))\n    end\n\n    vim.lsp.config(\"ask_language_server\", {\n\n        -- * language server\n        cmd = {\n            os.getenv(\"HOME\") .. \"/repos/github/g0t4/ask-openai.nvim/.venv/bin/python\",\n            \"-m\",\n            \"lsp.server\",\n        },\n        cmd_cwd = os.getenv(\"HOME\") .. \"/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag\",\n\n        -- old values from lspconfig setup => these might need adjusted if filetypes differs in vim.lsp.config\n        -- filetypes = rag_client.get_filetypes_for_workspace(),\n        -- filetypes = { '*' }, -- not set == all filetypes\n\n        root_dir = root_dir\n    })\n    -- log:info(vim.inspect(vim.lsp.config))\n\n    -- FYI troubleshooting:\n    -- - :checkhealth vim.lsp  # shows enabled vs active (buffer #s too)\n\n    vim.lsp.enable(\"ask_language_server\")\n\n    -- -- global handler\n    -- vim.lsp.handlers[\"window/showMessage\"] = function(err, result, ctx, config)\n    --     messages.append(\"global handler window/showMessage\")\n    --     messages.append(vim.inspect(result))\n    -- end\n\n    --- @alias EventArgs { id:number, event: string, group: number|nil, file: string, match: string, buf:number, data: table }\n    vim.api.nvim_create_autocmd('LspAttach', {\n        callback =\n        --- @param event_args EventArgs\n            function(event_args)\n                log:info(string.format(\"LspAttach: client_id=%s (buf %d)\", event_args.data.client_id, event_args.buf))\n                local client = vim.lsp.get_client_by_id(event_args.data.client_id)\n                if not client then\n                    return\n                end\n                if client.name ~= \"ask_language_server\" then\n                    return\n                end\n            end\n    })\n\n    -- if LS provides dynamic registration, then some capabilities aren't registered until after LspAttach event\n    vim.lsp.handlers['client/registerCapability'] = (function(overridden)\n        -- see :h LspAttach\n        return function(err, res, ctx)\n            log:info(string.format(\"client/registerCapability: client_id=%s\", ctx.client_id))\n            local result = overridden(err, res, ctx)\n            local client = vim.lsp.get_client_by_id(ctx.client_id)\n            if not client then\n                return\n            end\n            for bufnr, _ in pairs(client.attached_buffers) do\n                -- Call your custom on_attach logic...\n                -- my_on_attach(client, bufnr)\n            end\n            return result\n        end\n    end)(vim.lsp.handlers['client/registerCapability'])\n\n    vim.api.nvim_create_autocmd('LspDetach', {\n        callback =\n        --- @param event_args EventArgs\n            function(event_args)\n                <|fim_middle|>\n                local client = vim.lsp.get_client_by_id(event_args.data.client_id)\n                if not client then\n                    return\n                end\n                if client.name ~= \"ask_language_server\" then\n                    return\n                end\n\n                -- Remove the autocommand to format the buffer on save, if it exists\n                if client:supports_method('textDocument/formatting') then\n                    vim.api.nvim_clear_autocmds({\n                        event = 'BufWritePre',\n                        buffer = event_args.buf,\n                    })\n                end\n            end,\n    })\n\n    do return end\n    lspconfig.ask_language_server.setup({\n        on_attach = function(client, bufnr)\n            log:info(\"on_attach\")\n            -- messages.append(client.name .. \" is now attached to buffer: \" .. bufnr)\n            -- messages.ensure_open()\n            -- -- messages.append(vim.inspect(client))\n            client.handlers = {\n                [\"fuu/no_dot_rag__do_the_right_thing_wink\"] = function(err, result, ctx, config)\n                    messages.append(\"client handler fuu/no_dot_rag__do_the_right_thing_wink\")\n                    messages.append(vim.inspect(result))\n                    -- ask server to shutdown, so I don't ask for more stuff it cannot do!\n                    -- WHY THE F does this not request SHUTDOWN!?\n                    -- vim.lsp.stop_client(client)\n                    -- vim.lsp.stop_client(client)\n                end,\n                -- log server capabilities:\n                [\"workspace/initialize\"] = function(err, result, ctx, config)\n                    print(\"FUCK\")\n                    log:info(\"Server capabilities:\", vim.inspect(client.server_capabilities))\n                end\n\n\n                -- [\"window/showMessage\"] = function(err, result, ctx, config)\n                --     messages.append(\"client handler window/showMessage\")\n                --     messages.append(vim.inspect(result))\n                -- end,\n                -- [\"window/showMessageRequest\"] = function(err, result, ctx, config)\n                --     messages.append(\"client handler window/showMessageRequest\")\n                --     messages.append(vim.inspect(result))\n                -- end,\n                -- [\"window/logMessage\"] = function(err, result, ctx, config)\n                --     messages.append(\"client handler window/logMessage\")\n                --     messages.append(vim.inspect(result))\n                -- end,\n            }\n\n            -- vim.defer_fn(function()\n            --     local req_id0, cancel0 = vim.lsp.buf_request(0, \"workspace/executeCommand\", {\n            --         command = \"SLEEPY\",\n            --         arguments = { {} }, -- MUST have empty arguments in pygls v2... or set values inside arguments = { { seconds = 10 } },\n            --     }, function(err, result)\n            --         log:error(\"DONE error: \" .. vim.inspect(err) .. \" res:\" .. vim.inspect(result))\n            --     end)\n            --     -- vim.defer_fn(cancel0, 0) -- works fine to cancel all immediately and it does so VERY fast\n            --     vim.defer_fn(cancel0, 500)\n            --\n            --     local req_id1, cancel1 = vim.lsp.buf_request(0, \"workspace/executeCommand\", {\n            --         command = \"SLEEPY\",\n            --         arguments = { { seconds = 10 } },\n            --     }, function(err, result)\n            --         log:error(\"DONE error: \" .. vim.inspect(err) .. \" res:\" .. vim.inspect(result))\n            --     end)\n            --     vim.defer_fn(cancel1, 0)\n            --\n            --     local req_id2, cancel2 = vim.lsp.buf_request(0, \"workspace/executeCommand\", {\n            --         command = \"SLEEPY\",\n            --         arguments = { { seconds = 10 } },\n            --     }, function(err, result)\n            --         log:error(\"DONE error: \" .. vim.inspect(err) .. \" res:\" .. vim.inspect(result))\n            --     end)\n            --     vim.defer_fn(cancel2, 0)\n```\n\n## Reminders about the cursor line:\nText before cursor: `                `\nText before cursor is all whitespace (do not ignore this)",
        "_logged":true
      }],
    "raw":false,
    "model":"gpt-oss:120b",
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "stream":true
  },
  "last_sse":{
    "object":"chat.completion.chunk",
    "created":1772350616,
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "system_fingerprint":"b8115-77d6ae4ac",
    "timings":{
      "prompt_per_token_ms":0.24698787584869,
      "predicted_ms":615.158,
      "predicted_per_token_ms":4.7319846153846,
      "prompt_n":2062,
      "cache_n":1216,
      "prompt_per_second":4048.781732965,
      "prompt_ms":509.289,
      "predicted_per_second":211.32782147026,
      "predicted_n":130
    },
    "choices":[{
        "delta":[],
        "finish_reason":"stop",
        "index":0
      }],
    "id":"chatcmpl-wTVkLFAdCRV8ihXAMWAVPq94d8POOSHb"
  },
  "response_message":{
    "finish_reason":"stop",
    "content":"log:info(string.format(\"LspDetach: client_id=%s (buf %d)\", event_args.data.client_id, event_args.buf))",
    "reasoning_content":"We need code at <|fim_middle|> likely to log detach. Probably similar to attach block: log info. So insert log line. Also maybe return early if not client etc already below. At start of callback we need log. So code: `log:info(string.format(\"LspDetach: client_id=%s (buf %d)\", event_args.data.client_id, event_args.buf))` Then maybe get client. So fill that.",
    "role":"assistant",
    "_logged":true
  }
}